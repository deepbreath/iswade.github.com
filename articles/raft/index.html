<!doctype html><html lang="zh" class="no-js"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="x-ua-compatible" content="ie=edge"><link rel="canonical" href="https://iswade.github.io/articles/raft/"><meta name="lang:clipboard.copy" content="复制"><meta name="lang:clipboard.copied" content="已复制"><meta name="lang:search.language" content="ja"><meta name="lang:search.pipeline.stopwords" content="True"><meta name="lang:search.pipeline.trimmer" content="True"><meta name="lang:search.result.none" content="没有找到符合条件的结果"><meta name="lang:search.result.one" content="找到 1 个符合条件的结果"><meta name="lang:search.result.other" content="# 个符合条件的结果"><meta name="lang:search.tokenizer" content="[\uff0c\u3002]+"><link rel="shortcut icon" href="../../themes/favicon.png"><meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.3.1"><title>Raft博士论文 - Blog</title><link rel="stylesheet" href="../../assets/stylesheets/application.4031d38b.css"><link rel="stylesheet" href="../../assets/stylesheets/application-palette.224b79ff.css"><meta name="theme-color" content=""><script src="../../assets/javascripts/modernizr.74668098.js"></script><link href="https://fonts.gstatic.com" rel="preconnect" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=swap"><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link rel="stylesheet" href="../../assets/fonts/material-icons.css"><link rel="stylesheet" href="../../themes/extra.css"></head><body dir="ltr" data-md-color-primary="white" data-md-color-accent="blue"><svg class="md-svg"><defs></defs></svg> <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off"> <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off"> <label class="md-overlay" data-md-component="overlay" for="__drawer"></label><a href="#raft" tabindex="1" class="md-skip">跳转至 </a><header class="md-header" data-md-component="header"><nav class="md-header-nav md-grid"><div class="md-flex"><div class="md-flex__cell md-flex__cell--shrink"><a href="https://iswade.github.io/" title="Blog" class="md-header-nav__button md-logo"><img src="../../themes/me.jpg" width="24" height="24"></a></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label></div><div class="md-flex__cell md-flex__cell--stretch"><div class="md-flex__ellipsis md-header-nav__title" data-md-component="title"><span class="md-header-nav__topic">Blog</span><span class="md-header-nav__topic">Raft博士论文</span></div></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--search md-header-nav__button" for="__search"></label><div class="md-search" data-md-component="search" role="dialog"><label class="md-search__overlay" for="__search"></label><div class="md-search__inner" role="search"><form class="md-search__form" name="search"><input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active"> <label class="md-icon md-search__icon" for="__search"></label> <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button></form><div class="md-search__output"><div class="md-search__scrollwrap" data-md-scrollfix><div class="md-search-result" data-md-component="result"><div class="md-search-result__meta">键入以开始搜索</div><ol class="md-search-result__list"></ol></div></div></div></div></div></div></div></nav></header><div class="md-container"><main class="md-main"><div class="md-main__inner md-grid" data-md-component="container"><div class="md-sidebar md-sidebar--primary" data-md-component="navigation"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--primary" data-md-level="0"><label class="md-nav__title md-nav__title--site" for="__drawer"><a href="https://iswade.github.io/" title="Blog" class="md-nav__button md-logo"><img src="../../themes/me.jpg" width="48" height="48"></a>Blog</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../.." title="Home" class="md-nav__link">Home</a></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2"><label class="md-nav__link" for="nav-2">Databases</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-2">Databases</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../pebble/" title="Pebble KV存储引擎" class="md-nav__link">Pebble KV存储引擎</a></li><li class="md-nav__item"><a href="../../translate/faunadb_transaction/" title="FaunaDB的分布式事务协议" class="md-nav__link">FaunaDB的分布式事务协议</a></li><li class="md-nav__item"><a href="../../translate/Aurora_design_cloud_native_database/" title="Aurora云原生关系数据库" class="md-nav__link">Aurora云原生关系数据库</a></li><li class="md-nav__item"><a href="../../translate/btree_vs_lsmtree/" title="现代存储系统背后的算法" class="md-nav__link">现代存储系统背后的算法</a></li><li class="md-nav__item"><a href="../../notes/db_nodes/00_database_systems_2018/" title="数据库笔记" class="md-nav__link">数据库笔记</a></li><li class="md-nav__item"><a href="../../translate/F1_query/" title="F1 Query" class="md-nav__link">F1 Query</a></li><li class="md-nav__item"><a href="../boltdb/" title="Bolt 数据库" class="md-nav__link">Bolt 数据库</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3"><label class="md-nav__link" for="nav-3">Distributed</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-3">Distributed</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../translate/distsys/" title="分布式系统大纲" class="md-nav__link">分布式系统大纲</a></li><li class="md-nav__item"><a href="../../database/replication/" title="分布式系统之复制" class="md-nav__link">分布式系统之复制</a></li><li class="md-nav__item"><a href="../partition/" title="分布式系统之数据分区" class="md-nav__link">分布式系统之数据分区</a></li><li class="md-nav__item"><a href="../../database/db_internals_ch09_failure_detection/" title="分布式系统之故障检测" class="md-nav__link">分布式系统之故障检测</a></li><li class="md-nav__item"><a href="../../database/db_internals_ch14_consensus/" title="分布式系统之共识" class="md-nav__link">分布式系统之共识</a></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-6" type="checkbox" id="nav-3-6"><label class="md-nav__link" for="nav-3-6">分布式系统算法方法</label><nav class="md-nav" data-md-component="collapsible" data-md-level="2"><label class="md-nav__title" for="nav-3-6">分布式系统算法方法</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../distributed_systems/00_preface/" title="前 言" class="md-nav__link">前 言</a></li><li class="md-nav__item"><a href="../../distributed_systems/01_introduction/" title="第一章 概述" class="md-nav__link">第一章 概述</a></li><li class="md-nav__item"><a href="../../distributed_systems/02_interprocess/" title="第二章 进程间通信" class="md-nav__link">第二章 进程间通信</a></li><li class="md-nav__item"><a href="../../distributed_systems/03_models/" title="第三章 通信模型" class="md-nav__link">第三章 通信模型</a></li></ul></nav></li><li class="md-nav__item"><a href="../../translate/strong_consistency_models/" title="强一致性模型" class="md-nav__link">强一致性模型</a></li><li class="md-nav__item"><a href="../../translate/zookeeper/" title="Zookeeper论文翻译" class="md-nav__link">Zookeeper论文翻译</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4"><label class="md-nav__link" for="nav-4">Language</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-4">Language</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../go_concurrency/" title="Go 并发编程" class="md-nav__link">Go 并发编程</a></li><li class="md-nav__item"><a href="../../translate/go_interface/" title="如何使用 Go 接口" class="md-nav__link">如何使用 Go 接口</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5"><label class="md-nav__link" for="nav-5">Engineering</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-5">Engineering</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../advanced_markdown/" title="高级markdown" class="md-nav__link">高级markdown</a></li><li class="md-nav__item"><a href="../../translate/linux_sysadmin/" title="linux 系统管理" class="md-nav__link">linux 系统管理</a></li><li class="md-nav__item"><a href="../../notes/git/" title="git 入门教程" class="md-nav__link">git 入门教程</a></li><li class="md-nav__item"><a href="../../translate/to_be_manager/" title="How to be a manager" class="md-nav__link">How to be a manager</a></li></ul></nav></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component="toc"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--secondary"></nav></div></div></div><div class="md-content"><article class="md-content__inner md-typeset"><h1 id="raft">Raft博士论文</h1>
<p>Raft支持日志条目的批处理和流水线化，两者对于实现最佳性能都很重要。当将多个请求收集到批处理中时，将分摊许多请求处理成本。例如，通过网络在一个数据包中发送两个条目比在两个单独的数据包中发送两个条目，或者一次将两个条目写入磁盘要快得多。因此，大批量可优化吞吐量，并且在系统承受重负载时非常有用。另一方面，流水线通过允许在处理另一个条目时开始处理一个条目来优化中等负载下的延迟。例如，当跟随者将前一个条目写入磁盘时，流水线操作允许领导者将网络上的下一个条目复制到该跟随者。即使在高负载下，流水数量也可以通过更有效地利用资源来提高吞吐量。例如，跟随者需要先通过网络接收条目，然后才能将其写入磁盘。批量处理不能一次使用这两种资源，但流水线可以。流水线在某种程度上也不利于批处理。例如，整体上延迟请求并向跟踪者发送一大批，而不是通过管道处理多个小请求，整体上可能更快。批处理在Raft中很自然地实现，因为AppendEntries支持在一个RPC中发送多个连续的条目。 LogCabin的领导者会在追随者的下一个索引和日志结尾之间发送尽可能多的条目，最大大小为1兆字节。一个1 MB的限制是任意的，但足以有效地使用网络和磁盘，同时仍向追随者提供频繁的心跳（如果一个RPC太大，追随者可能会怀疑失败的领导者并开始选举）。然后，跟随者将来自单个AppendEntries请求的所有新条目立即写入其磁盘，从而有效利用其磁盘。 Raft也对流水线提供了很好的支持。 AppendEntries一致性检查可确保流水线操作安全；实际上，领导者可以安全地以任何顺序发送条目。为了支持流水线，领导者乐观地对待每个关注者的下一个索引；它会更新下一个索引，以在发送上一个条目之后立即发送，而不是等待上一个条目的确认。这允许另一个RPC在下一个条目之后传递下一个条目。如果RPC失败，簿记将涉及更多。</p>
<p>如果RPC超时，则领导者必须将其下一个索引递减回其原始值以重试。如果AppendEntries一致性检查失败，则领导者可以进一步降低下一个索引，以重试发送先前的条目，或者可以等待该先前的条目被确认然后再试一次。即使进行了此更改，LogCabin的原始线程体系结构仍然阻止了流水线操作，因为每个追随者只能支持一个RPC。因此，我们对其进行了更改，以使每个对等点产生多个线程而不是一个。如果希望在正常情况下按顺序传递消息，则这种流水线方法最有效，因为重新排序可能会导致重传效率低下。幸运的是，大多数环境不会经常重新排序消息。例如，LogCabin中的领导者使用与每个跟随者的单个TCP连接，并且仅在怀疑失败时才切换到新连接。由于单个TCP连接会屏蔽应用程序中的网络级重新排序，因此LogCabin关注者很少会乱序接收AppendEntries请求。如果网络通常对请求进行重新排序，则应用程序可能会从临时缓存乱序请求中受益，直到可以将它们按顺序追加到日志中为止。筏系统的整体性能在很大程度上取决于如何安排批生产和管道。如果在高负载下无法在一批中累积足够的请求，则整个处理将效率低下，从而导致低吞吐量和高延迟。另一方面，如果在一个批次中累积了太多请求，则延迟将不必要地增加，因为较早的请求会等待较晚的请求到达。尽管我们仍在研究最佳策略，但我们的目标是最大程度地减少动态工作负载下请求的平均延迟。在LogCabin中实现流水线操作之前，它使用了一种简单的双缓冲技术。领导者将为每个关注者保留一个出色的RPC。当该RPC返回时，它将发送另一个带有同时已累积的日志条目的RPC，如果没有更多的可用条目，则在添加下一个RPC之后将立即发送下一个RPC。这种方法很有吸引力，因为它可以动态调整以适应负载。一旦负载增加，条目就会累积，下一批将更大，从而提高了效率。一旦负载减少，批次将缩小大小，从而降低了延迟。我们希望保留此行为以进行流水线处理。直观地讲，在两级流水线中，我们希望第二批在第一批处理时间的中途开始，从而将平均延迟减半。但是，猜测批处理何时完成需要估计往返时间。我们仍在研究在LogCabin中使用的最佳策略。</p>
<h1 id="raft_1">Raft</h1>
<p>单节点</p>
<ol>
<li>单节点故障</li>
<li>业务数据无法存放</li>
</ol>
<p>复制</p>
<ol>
<li>Master-Standby</li>
<li>异步复制：丢数据</li>
<li>同步复制：主节点宕机后如何处理？备机又是单节点存在上面的问题</li>
<li>Quorum：2N+1，允许一台宕机，升主问题，脑裂问题（读到旧的数据，不一致，线性一致性）</li>
<li>线性一致性</li>
</ol>
<p>共识算法</p>
<ul>
<li>共享状态达成一致</li>
<li>自动故障恢复</li>
<li>强一致性（线性化）</li>
</ul>
<p>Raft</p>
<p>（说明 paxos，raft 历史以及相关信息）</p>
<p>keypoints</p>
<ul>
<li>对复制状态机复制日志</li>
<li>Leader、Follower，Candidate</li>
<li>任期与领导选举</li>
<li>日志复制</li>
<li>成员变更</li>
</ul>
<p>复制状态机</p>
<ul>
<li>客户端、服务器</li>
<li>共识模块</li>
<li>状态机</li>
<li>日志</li>
</ul>
<p>角色</p>
<ul>
<li>领导者</li>
<li>仅一个领导者</li>
<li>由多数派节点选举而来</li>
<li>处理所有其它客户端的请求</li>
<li>跟随者</li>
<li>接受领导者的复制日志</li>
<li>候选者</li>
<li>选举</li>
</ul>
<p>任期</p>
<ul>
<li>时间问题，raft 不依赖时间，将时间分割为不同的term</li>
</ul>
<p>选举</p>
<ul>
<li>状态机转换图</li>
</ul>
<p>日志复制</p>
<ul>
<li>多数派复制</li>
<li>日志提交</li>
<li>异步将已经提交 index 发送给跟随者</li>
</ul>
<p>快照</p>
<ul>
<li>Leader 生成快照</li>
<li>截断日志</li>
<li>发送日志</li>
</ul>
<p>成员变更</p>
<ul>
<li>增加节点，在线</li>
<li>一次增加多个节点会违反 Raft 协议，一次增加一个节点</li>
<li><a href="https://www.jianshu.com/p/99562bfec5c2">joint consensus</a></li>
</ul>
<p>优化</p>
<ul>
<li>Pre-Vote：由于网络抖动一个 follower 发起选举，但是其它人都是 OK 的</li>
<li>Pipeline：</li>
<li>Batch：Pospose(req1,req2,req3) &rarr; Append</li>
<li>领导者并行发送，日志落盘</li>
<li>Non-Voter: 追日志过程中，不投票状态，不干扰已有集群</li>
<li>参考：<a href="https://www.jianshu.com/p/1bbd7162727d">博文</a></li>
</ul>
<p>Multi-Raft</p>
<ul>
<li>Range: 分割</li>
<li>Raft Group</li>
<li>Scale-Out：平衡</li>
</ul>
<h1 id="_1">其它</h1>
<p>coordinator 如何使用 raft 或者 paxos 来保证高可用？解决2PC残留问题。</p>
<ul>
<li>多CN写入，多节点互相备份，挂掉一个不影响其它CN，2PC信息不回丢失</li>
<li>冲突处理</li>
<li>multi-Raft支持？</li>
</ul>
<ol>
<li>节点变更：两个节点到一个节点如何处理？参考 etcd raft readme</li>
</ol>
<p>两个节点需要多数派（也就是两个节点都正常时）先写入一条节点变更的日志，然后删除另一个节点</p>
<ol start="2">
<li>如果少数节点写入了日志，这一条日志一定会被丢弃吗？如果多数节点写入日志，但是客户端还没有收到应答，服务器就宕机了。客户端如何处理？仅写入一次的语义如何保证？</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/98102934">各类Consistency对比小结</a></p></article></div></div></main><footer class="md-footer"><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class="md-footer-copyright"><div class="md-footer-copyright__highlight">Copyright &copy; 2016 - 2019 iswade</div>powered by <a href="https://www.mkdocs.org">MkDocs</a> and <a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a></div></div></div></footer></div><script src="../../assets/javascripts/application.d5a09f94.js"></script><script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script><script src="../../assets/javascripts/lunr/tinyseg.js"></script><script src="../../assets/javascripts/lunr/lunr.ja.js"></script><script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>