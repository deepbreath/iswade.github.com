<!doctype html><html lang="zh" class="no-js"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="x-ua-compatible" content="ie=edge"><link rel="canonical" href="https://iswade.github.io/notes/adb_nodes/15_execution/"><meta name="lang:clipboard.copy" content="复制"><meta name="lang:clipboard.copied" content="已复制"><meta name="lang:search.language" content="ja"><meta name="lang:search.pipeline.stopwords" content="True"><meta name="lang:search.pipeline.trimmer" content="True"><meta name="lang:search.result.none" content="没有找到符合条件的结果"><meta name="lang:search.result.one" content="找到 1 个符合条件的结果"><meta name="lang:search.result.other" content="# 个符合条件的结果"><meta name="lang:search.tokenizer" content="[\uff0c\u3002]+"><link rel="shortcut icon" href="../../../themes/favicon.png"><meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.3.1"><title>15 execution - Blog</title><link rel="stylesheet" href="../../../assets/stylesheets/application.4031d38b.css"><link rel="stylesheet" href="../../../assets/stylesheets/application-palette.224b79ff.css"><meta name="theme-color" content=""><script src="../../../assets/javascripts/modernizr.74668098.js"></script><link href="https://fonts.gstatic.com" rel="preconnect" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=swap"><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link rel="stylesheet" href="../../../assets/fonts/material-icons.css"><link rel="stylesheet" href="../../../themes/extra.css"></head><body dir="ltr" data-md-color-primary="white" data-md-color-accent="blue"><svg class="md-svg"><defs></defs></svg> <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off"> <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off"> <label class="md-overlay" data-md-component="overlay" for="__drawer"></label><a href="#_1" tabindex="1" class="md-skip">跳转至 </a><header class="md-header" data-md-component="header"><nav class="md-header-nav md-grid"><div class="md-flex"><div class="md-flex__cell md-flex__cell--shrink"><a href="https://iswade.github.io/" title="Blog" class="md-header-nav__button md-logo"><img src="../../../themes/me.jpg" width="24" height="24"></a></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label></div><div class="md-flex__cell md-flex__cell--stretch"><div class="md-flex__ellipsis md-header-nav__title" data-md-component="title"><span class="md-header-nav__topic">Blog</span><span class="md-header-nav__topic">15 execution</span></div></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--search md-header-nav__button" for="__search"></label><div class="md-search" data-md-component="search" role="dialog"><label class="md-search__overlay" for="__search"></label><div class="md-search__inner" role="search"><form class="md-search__form" name="search"><input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active"> <label class="md-icon md-search__icon" for="__search"></label> <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button></form><div class="md-search__output"><div class="md-search__scrollwrap" data-md-scrollfix><div class="md-search-result" data-md-component="result"><div class="md-search-result__meta">键入以开始搜索</div><ol class="md-search-result__list"></ol></div></div></div></div></div></div></div></nav></header><div class="md-container"><main class="md-main"><div class="md-main__inner md-grid" data-md-component="container"><div class="md-sidebar md-sidebar--primary" data-md-component="navigation"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--primary" data-md-level="0"><label class="md-nav__title md-nav__title--site" for="__drawer"><a href="https://iswade.github.io/" title="Blog" class="md-nav__button md-logo"><img src="../../../themes/me.jpg" width="48" height="48"></a>Blog</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../.." title="Home" class="md-nav__link">Home</a></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2"><label class="md-nav__link" for="nav-2">Databases</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-2">Databases</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../../articles/pebble/" title="Pebble KV存储引擎" class="md-nav__link">Pebble KV存储引擎</a></li><li class="md-nav__item"><a href="../../../translate/faunadb_transaction/" title="FaunaDB的分布式事务协议" class="md-nav__link">FaunaDB的分布式事务协议</a></li><li class="md-nav__item"><a href="../../../translate/Aurora_design_cloud_native_database/" title="Aurora:如何设计云原生关系数据库" class="md-nav__link">Aurora:如何设计云原生关系数据库</a></li><li class="md-nav__item"><a href="../../../translate/btree_vs_lsmtree/" title="现代存储系统背后的算法" class="md-nav__link">现代存储系统背后的算法</a></li><li class="md-nav__item"><a href="../../db_nodes/00_database_systems_2018/" title="数据库笔记" class="md-nav__link">数据库笔记</a></li><li class="md-nav__item"><a href="../../../translate/F1_query/" title="F1 Query" class="md-nav__link">F1 Query</a></li><li class="md-nav__item"><a href="../../../articles/boltdb/" title="Bolt 数据库" class="md-nav__link">Bolt 数据库</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3"><label class="md-nav__link" for="nav-3">Distributed</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-3">Distributed</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../../translate/distsys/" title="分布式系统大纲" class="md-nav__link">分布式系统大纲</a></li><li class="md-nav__item"><a href="../../../articles/partition/" title="分布式系统之数据分区" class="md-nav__link">分布式系统之数据分区</a></li><li class="md-nav__item"><a href="../../../database/db_internals_ch09_failure_detection/" title="分布式系统之故障检测" class="md-nav__link">分布式系统之故障检测</a></li><li class="md-nav__item"><a href="../../../database/db_internals_ch14_consensus/" title="分布式系统之共识" class="md-nav__link">分布式系统之共识</a></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-3-5" type="checkbox" id="nav-3-5"><label class="md-nav__link" for="nav-3-5">分布式系统：算法方法</label><nav class="md-nav" data-md-component="collapsible" data-md-level="2"><label class="md-nav__title" for="nav-3-5">分布式系统：算法方法</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../../distributed_systems/00_preface/" title="前 言" class="md-nav__link">前 言</a></li><li class="md-nav__item"><a href="../../../distributed_systems/01_introduction/" title="第一章 概述" class="md-nav__link">第一章 概述</a></li><li class="md-nav__item"><a href="../../../distributed_systems/02_interprocess/" title="第二章 进程间通信" class="md-nav__link">第二章 进程间通信</a></li><li class="md-nav__item"><a href="../../../distributed_systems/03_models/" title="第三章 通信模型" class="md-nav__link">第三章 通信模型</a></li></ul></nav></li><li class="md-nav__item"><a href="../../../translate/strong_consistency_models/" title="强一致性模型" class="md-nav__link">强一致性模型</a></li><li class="md-nav__item"><a href="../../../translate/zookeeper/" title="Zookeeper论文翻译" class="md-nav__link">Zookeeper论文翻译</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4"><label class="md-nav__link" for="nav-4">Language</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-4">Language</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../../articles/go_concurrency/" title="Go 并发编程" class="md-nav__link">Go 并发编程</a></li><li class="md-nav__item"><a href="../../../translate/go_interface/" title="如何使用 Go 接口" class="md-nav__link">如何使用 Go 接口</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5"><label class="md-nav__link" for="nav-5">Engineering</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-5">Engineering</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../../advanced_markdown/" title="高级markdown" class="md-nav__link">高级markdown</a></li><li class="md-nav__item"><a href="../../../translate/linux_sysadmin/" title="linux 系统管理" class="md-nav__link">linux 系统管理</a></li><li class="md-nav__item"><a href="../../git/" title="git 入门教程" class="md-nav__link">git 入门教程</a></li><li class="md-nav__item"><a href="../../../translate/to_be_manager/" title="How to be a manager" class="md-nav__link">How to be a manager</a></li></ul></nav></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component="toc"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--secondary"><label class="md-nav__title" for="__toc">目录</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="#_2" title="算子执行" class="md-nav__link">算子执行</a></li><li class="md-nav__item"><a href="#_3" title="查询执行" class="md-nav__link">查询执行</a></li><li class="md-nav__item"><a href="#_4" title="执行优化" class="md-nav__link">执行优化</a></li><li class="md-nav__item"><a href="#_5" title="优化目标" class="md-nav__link">优化目标</a></li><li class="md-nav__item"><a href="#monetdbx100" title="MonetDB/X100" class="md-nav__link">MonetDB/X100</a></li><li class="md-nav__item"><a href="#cpu" title="CPU 概览" class="md-nav__link">CPU 概览</a></li><li class="md-nav__item"><a href="#dbmscpu" title="DBMS/CPU 问题" class="md-nav__link">DBMS/CPU 问题</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#_6" title="分支预测错误" class="md-nav__link">分支预测错误</a></li><li class="md-nav__item"><a href="#selection" title="SELECTION扫描" class="md-nav__link">SELECTION扫描</a></li></ul></nav></li><li class="md-nav__item"><a href="#_7" title="过多的指令" class="md-nav__link">过多的指令</a></li><li class="md-nav__item"><a href="#_8" title="处理模型" class="md-nav__link">处理模型</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#_9" title="迭代模型" class="md-nav__link">迭代模型</a></li><li class="md-nav__item"><a href="#_10" title="物化模型" class="md-nav__link">物化模型</a></li><li class="md-nav__item"><a href="#_11" title="向量化模型" class="md-nav__link">向量化模型</a></li></ul></nav></li><li class="md-nav__item"><a href="#_12" title="计划执行方向" class="md-nav__link">计划执行方向</a></li><li class="md-nav__item"><a href="#_13" title="并行" class="md-nav__link">并行</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#_14" title="查询间并行" class="md-nav__link">查询间并行</a></li><li class="md-nav__item"><a href="#_15" title="查询内并行" class="md-nav__link">查询内并行</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#_16" title="算子内" class="md-nav__link">算子内</a></li><li class="md-nav__item"><a href="#_17" title="算子间并行" class="md-nav__link">算子间并行</a></li></ul></nav></li><li class="md-nav__item"><a href="#_18" title="观察" class="md-nav__link">观察</a></li><li class="md-nav__item"><a href="#_19" title="工作线程分配" class="md-nav__link">工作线程分配</a></li><li class="md-nav__item"><a href="#_20" title="任务分配" class="md-nav__link">任务分配</a></li><li class="md-nav__item"><a href="#_21" title="部分思考" class="md-nav__link">部分思考</a></li></ul></nav></li></ul></nav></div></div></div><div class="md-content"><article class="md-content__inner md-typeset"><h1 id="_1">查询执行处理</h1>
<h2 id="_2">算子执行</h2>
<p>查询计划处理</p>
<p>应用逻辑执行（UDFs）</p>
<p>并行 JOIN 算法</p>
<p>向量化算子</p>
<p>查询编译</p>
<h2 id="_3">查询执行</h2>
<p>一个查询计划由<strong>算子</strong>组成</p>
<p>一个<strong>算子实例</strong>是对数据的某个片段的一个算子的一次调用</p>
<p>一个<strong>任务</strong>是一个或者多个算子实例的执行序列</p>
<h2 id="_4">执行优化</h2>
<p>我们现在就开始讨论提升数据集在内存中的 DBMS 查询执行性能的各种方法。</p>
<p>当我们移除磁盘之后，达成目标有其它的瓶颈。</p>
<h2 id="_5">优化目标</h2>
<ol>
<li>减少指令个数：使用更少的指令完成相同的工作。</li>
<li>减少每个指令的周期：在更少的周期内执行更多的 CPU 指令；这意味着减少因为内存加载而导致的缓存未命中和停顿。</li>
<li>并行化执行：使用多线程并行计算每个查询。</li>
</ol>
<h2 id="monetdbx100">MonetDB/X100</h2>
<p>对 OLAP 负载内存 DBMS 执行瓶颈的底层分析。展示DBMS如何针对现代CPU架构进行不正确的设计。</p>
<p>基于这些发现，他们提出了一个新的 DBMS 叫做 MonetDB/X100。</p>
<ul>
<li>重命名为 Vectorwise 在 2010 年被 Action 收购。</li>
<li>品牌为Vector and Avalanche。</li>
</ul>
<h2 id="cpu">CPU 概览</h2>
<p>CPU 将指令组织为 <strong>pipeline 阶段</strong>。目标是通过屏蔽在单个周期内无法完成的指令的延迟来保持处理器的所有部分在每个周期都忙。</p>
<p>超标量 CPU 支持多个管道。在单个周期内如果指令是独立的，可以并行执行多个指令；Flynn的分类：SISD。</p>
<h2 id="dbmscpu">DBMS/CPU 问题</h2>
<ol>
<li>问题1：依赖，如果一个指令依赖另一个指令，则不能被立即推送到同一个 pipeline 上。</li>
<li>问题2：分支预测，CPU 超市预测程序的分支，并且将其指令填充到 pipeline 上；如果预测错误，它必须抛弃任前面的预测工作并冲洗管道。</li>
</ol>
<h3 id="_6">分支预测错误</h3>
<p>由于管道较长，CPU会推测性地执行分支。 这可能会隐藏相关指令之间的长时间停顿。</p>
<p>DBMS 中执行最多的分支是顺序扫描过程中的过滤操作，但这几乎无法正确预测。</p>
<h3 id="selection">SELECTION扫描</h3>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #008800; font-weight: bold">SELECT</span> * <span style="color: #008800; font-weight: bold">FROM</span> <span style="color: #008800; font-weight: bold">table</span> <span style="color: #008800; font-weight: bold">WHERE</span> <span style="color: #008800; font-weight: bold">key</span> &gt;= <span style="color: #a61717; background-color: #e3d2d2">$</span>(low) <span style="color: #008800; font-weight: bold">AND</span> <span style="color: #008800; font-weight: bold">key</span> &lt;= <span style="color: #a61717; background-color: #e3d2d2">$</span>(high)
</pre></div>

<p>分支：</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span>i = <span style="color: #0000DD; font-weight: bold">0</span>
<span style="color: #008800; font-weight: bold">for</span> t <span style="color: #008800">in</span> table:
  key = t.key
  <span style="color: #008800; font-weight: bold">if</span> (key<span style="color: #a61717; background-color: #e3d2d2">≥</span>low) &amp;&amp; (key<span style="color: #a61717; background-color: #e3d2d2">≤</span>high):
    copy(t, output[i])
    i = i + <span style="color: #0000DD; font-weight: bold">1</span>
</pre></div>

<p>非分支：</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span>i = <span style="color: #0000DD; font-weight: bold">0</span>
<span style="color: #008800; font-weight: bold">for</span> t <span style="color: #008800">in</span> table:
  copy(t, output[i])
  key = t.key
  m = (key<span style="color: #a61717; background-color: #e3d2d2">≥</span>low <span style="color: #a61717; background-color: #e3d2d2">?</span> <span style="color: #0000DD; font-weight: bold">1</span> : <span style="color: #0000DD; font-weight: bold">0</span>) &amp;&amp; (key<span style="color: #a61717; background-color: #e3d2d2">≤</span>high <span style="color: #a61717; background-color: #e3d2d2">?</span> <span style="color: #0000DD; font-weight: bold">1</span> : <span style="color: #0000DD; font-weight: bold">0</span>)
  i = i + m
</pre></div>

<p><img alt="image-20190406083525496" src="../image/15_execute_branch_branchless.png" /></p>
<h2 id="_7">过多的指令</h2>
<p>DBMS 需要支持不同数据类型，所以必须在执行对这个值得任何操作之前，检查一个值的类型。</p>
<ul>
<li>这通常实现为一个很大的 switch 语句。</li>
<li>还创建了更多分支，导致 CPU 很难来可靠地预测。</li>
</ul>
<p>例如：Postgres 对 NUMBERIC 类型的加法。</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span> <span style="color: #888888; font-weight: bold">int</span> <span style="color: #0066bb; font-weight: bold">PGTYPESnumeric_add</span>(numeric *var1, numeric *var2, numeric *result)
 {
     <span style="color: #888888">/*</span>
<span style="color: #888888">      * Decide on the signs of the two variables what to do</span>
<span style="color: #888888">      */</span>
     <span style="color: #008800; font-weight: bold">if</span> (var1-&gt;sign == NUMERIC_POS)
     {
         <span style="color: #008800; font-weight: bold">if</span> (var2-&gt;sign == NUMERIC_POS)
         {
             <span style="color: #888888">/*</span>
<span style="color: #888888">              * Both are positive result = +(ABS(var1) + ABS(var2))</span>
<span style="color: #888888">              */</span>
             <span style="color: #008800; font-weight: bold">if</span> (add_abs(var1, var2, result) != <span style="color: #0000DD; font-weight: bold">0</span>)
                 <span style="color: #008800; font-weight: bold">return</span> -<span style="color: #0000DD; font-weight: bold">1</span>;
             result-&gt;sign = NUMERIC_POS;
         }
         <span style="color: #008800; font-weight: bold">else</span>
         {
             <span style="color: #888888">/*</span>
<span style="color: #888888">              * var1 is positive, var2 is negative Must compare absolute values</span>
<span style="color: #888888">              */</span>
             <span style="color: #008800; font-weight: bold">switch</span> (cmp_abs(var1, var2))
             {
                 <span style="color: #008800; font-weight: bold">case</span> <span style="color: #0000DD; font-weight: bold">0</span>:
                     <span style="color: #888888">/* ----------</span>
<span style="color: #888888">                      * ABS(var1) == ABS(var2)</span>
<span style="color: #888888">                      * result = ZERO</span>
<span style="color: #888888">                      * ----------</span>
<span style="color: #888888">                      */</span>
                     zero_var(result);
                     result-&gt;rscale = Max(var1-&gt;rscale, var2-&gt;rscale);
                     result-&gt;dscale = Max(var1-&gt;dscale, var2-&gt;dscale);
                     <span style="color: #008800; font-weight: bold">break</span>;

                 <span style="color: #008800; font-weight: bold">case</span> <span style="color: #0000DD; font-weight: bold">1</span>:
                     <span style="color: #888888">/* ----------</span>
<span style="color: #888888">                      * ABS(var1) &gt; ABS(var2)</span>
<span style="color: #888888">                      * result = +(ABS(var1) - ABS(var2))</span>
<span style="color: #888888">                      * ----------</span>
<span style="color: #888888">                      */</span>
                     <span style="color: #008800; font-weight: bold">if</span> (sub_abs(var1, var2, result) != <span style="color: #0000DD; font-weight: bold">0</span>)
                         <span style="color: #008800; font-weight: bold">return</span> -<span style="color: #0000DD; font-weight: bold">1</span>;
                     result-&gt;sign = NUMERIC_POS;
                     <span style="color: #008800; font-weight: bold">break</span>;

                 <span style="color: #008800; font-weight: bold">case</span> -<span style="color: #0000DD; font-weight: bold">1</span>:
                     <span style="color: #888888">/* ----------</span>
<span style="color: #888888">                      * ABS(var1) &lt; ABS(var2)</span>
<span style="color: #888888">                      * result = -(ABS(var2) - ABS(var1))</span>
<span style="color: #888888">                      * ----------</span>
<span style="color: #888888">                      */</span>
                     <span style="color: #008800; font-weight: bold">if</span> (sub_abs(var2, var1, result) != <span style="color: #0000DD; font-weight: bold">0</span>)
                         <span style="color: #008800; font-weight: bold">return</span> -<span style="color: #0000DD; font-weight: bold">1</span>;
                     result-&gt;sign = NUMERIC_NEG;
                     <span style="color: #008800; font-weight: bold">break</span>;
 ......
</pre></div>

<h2 id="_8">处理模型</h2>
<p>DBMS 的处理模型定义系统执行一个查询计划如何执行：对不同负载的不同权衡。</p>
<ol>
<li>方法1：迭代模型</li>
<li>方法2：物化模型</li>
<li>方法3：向量化/批量模型</li>
</ol>
<h3 id="_9">迭代模型</h3>
<p>每个查询计划算子实现一个 next 函数。</p>
<ul>
<li>在每次调用的时候，算子返回单个原则或者一个 null 标识符。</li>
<li>算子实现一个循环对孩子调用 next 来查找它们的元组然后处理它们。</li>
</ul>
<p>也叫做 Volcano 或者 Pipeline 模型。</p>
<p><img alt="image-20190406091130993" src="../image/15_iterator.png" /></p>
<p>这通常是几乎每个 DBMS 使用的模型。允许元组的 pipelining。</p>
<p>一些算子必须阻塞直到它们的孩子节点发送出所有的元组。</p>
<ul>
<li>Join，子查询，order by</li>
</ul>
<p>使用这种方法，输出控制很容易。</p>
<h3 id="_10">物化模型</h3>
<p>每个算子处理一次处理所有输入，每个发送所有的输出。</p>
<ul>
<li>算子将其结果物化为单个结果。</li>
<li>DBMS 可以将提示信息下推，避免扫描太多元组。</li>
<li>可以发送一个物化的行和单个行。</li>
</ul>
<p>输出可以是整个元组或者列的子集。</p>
<p>对于 OLTP 负载更好，因为通常一个查询通常仅访问很小数量的元组。</p>
<ul>
<li>更低的查询/协调开销。</li>
<li>更少的函数调用。</li>
</ul>
<p>对于立即返回大量结果的 OLAP 查询不友好。</p>
<p>MonetDB/VoltDB/HYRISE</p>
<h3 id="_11">向量化模型</h3>
<p>跟迭代模型很像，每个算子实现一个 next 函数。</p>
<p>每个算子发送一批元组而不是单个元组。</p>
<ul>
<li>每个算子内部循环一次处理多个元组。</li>
<li>一批的大小可以根据硬件或者查询属性变化。</li>
</ul>
<p>对于 OLAP 查询很友好，因为会大幅度减少每个算子的调用数量。</p>
<p>允许算子使用向量化指令(SIMD)来处理一批元组。</p>
<h2 id="_12">计划执行方向</h2>
<ol>
<li>自顶向下</li>
</ol>
<p>从根节点开始，从其孩子节点上 pull 数据。</p>
<p>元组总是通过函数调用来传递。</p>
<ol start="2">
<li>自底向上</li>
</ol>
<p>从叶子节点开始将数据 push 到父节点。</p>
<p>允许在 pipeline 中对缓存、寄存器更紧密的控制</p>
<p>我们后面会在 Hyper 和 Pelton ROF 中看到。</p>
<h2 id="_13">并行</h2>
<h3 id="_14">查询间并行</h3>
<p>多个查询同时进行提高整体性能。通过并发控制模式提供隔离的假象。</p>
<p>实现一个并发控制模式的难度，不会受到 DBMS 处理模型的显著影响。</p>
<h3 id="_15">查询内并行</h3>
<p>通过并行执行单个查询来提升性能。</p>
<ol>
<li>算子内（水平）</li>
<li>算子间（垂直）</li>
</ol>
<p>这些技术并不是互斥的。每个关系算子都有并行化算法。</p>
<h4 id="_16">算子内</h4>
<p>算子被分解为独立的示例来执行不同数据子集的相同函数。</p>
<p>DBMS 插入一个 exchange 算子到查询计划中合并孩子算子的结果。</p>
<p><img alt="image-20190406162614992" src="../image/15_exchange_operator.png" /></p>
<h4 id="_17">算子间并行</h4>
<p>算子是重叠的，以便将数据从一个阶段传递到下一个阶段，而不需要物化。</p>
<p>也叫做 pipelined 并行。</p>
<p>AFAIK，这种方法不被传统关系数据库广泛使用。</p>
<ul>
<li>不是所有算子能够发送输出，直到其看到所有孩子的元组之后。</li>
<li>在流式处理系统中更加常见。</li>
</ul>
<p><img alt="image-20190406165516226" src="../image/15_inter_operator_parallelism.png" /></p>
<h3 id="_18">观察</h3>
<p>提供适当数量的工作程序用于查询计划，取决于 CPU 的核心数、数据大小和算子的功能。</p>
<h3 id="_19">工作线程分配</h3>
<ol>
<li>每个核心一个工作线程。每个核心分配一个线程并绑定到那个核心上；设置<a href="http://man7.org/linux/man-pages/man2/sched_setaffinity.2.html">亲和性</a>。</li>
<li>每个核心多个工作线程。每个核或者每个连接一个工作线程池；单个核心阻塞之后，CPU 核心会被充分使用。</li>
</ol>
<h3 id="_20">任务分配</h3>
<ol>
<li>Push：一个中心化的分配器用来分配任务到工作线程，监视其处理；当工作线程通知分配器完成后，会被分配一个新的任务。</li>
<li>Pull：工作线程从一个队列中获取下一个任务，处理，然后接着处理下一个。</li>
</ol>
<h3 id="_21">部分思考</h3>
<p>对于现代 CPU 而言，最容易的实现方式通常并不会产生最有效的执行策略。</p>
<p>我们我们会看到向量化/自底向上执行对于 OLAP 查询更加合适。</p></article></div></div></main><footer class="md-footer"><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class="md-footer-copyright"><div class="md-footer-copyright__highlight">Copyright &copy; 2016 - 2019 iswade</div>powered by <a href="https://www.mkdocs.org">MkDocs</a> and <a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a></div></div></div></footer></div><script src="../../../assets/javascripts/application.d5a09f94.js"></script><script src="../../../assets/javascripts/lunr/lunr.stemmer.support.js"></script><script src="../../../assets/javascripts/lunr/tinyseg.js"></script><script src="../../../assets/javascripts/lunr/lunr.ja.js"></script><script>app.initialize({version:"1.0.4",url:{base:"../../.."}})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>