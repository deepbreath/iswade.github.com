<!doctype html><html lang="zh" class="no-js"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="x-ua-compatible" content="ie=edge"><link rel="canonical" href="https://iswade.github.io/translate/crdb/crdb_join/"><meta name="lang:clipboard.copy" content="复制"><meta name="lang:clipboard.copied" content="已复制"><meta name="lang:search.language" content="ja"><meta name="lang:search.pipeline.stopwords" content="True"><meta name="lang:search.pipeline.trimmer" content="True"><meta name="lang:search.result.none" content="没有找到符合条件的结果"><meta name="lang:search.result.one" content="找到 1 个符合条件的结果"><meta name="lang:search.result.other" content="# 个符合条件的结果"><meta name="lang:search.tokenizer" content="[\uff0c\u3002]+"><link rel="shortcut icon" href="../../../themes/favicon.png"><meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.3.1"><title>CockroachDB 中的 JOIN - Blog</title><link rel="stylesheet" href="../../../assets/stylesheets/application.4031d38b.css"><link rel="stylesheet" href="../../../assets/stylesheets/application-palette.224b79ff.css"><meta name="theme-color" content=""><script src="../../../assets/javascripts/modernizr.74668098.js"></script><link href="https://fonts.gstatic.com" rel="preconnect" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=swap"><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link rel="stylesheet" href="../../../assets/fonts/material-icons.css"><link rel="stylesheet" href="../../../themes/extra.css"></head><body dir="ltr" data-md-color-primary="white" data-md-color-accent="blue"><svg class="md-svg"><defs></defs></svg> <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off"> <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off"> <label class="md-overlay" data-md-component="overlay" for="__drawer"></label><a href="#cockroachdb-join" tabindex="1" class="md-skip">跳转至 </a><header class="md-header" data-md-component="header"><nav class="md-header-nav md-grid"><div class="md-flex"><div class="md-flex__cell md-flex__cell--shrink"><a href="https://iswade.github.io/" title="Blog" class="md-header-nav__button md-logo"><img src="../../../themes/me.jpg" width="24" height="24"></a></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label></div><div class="md-flex__cell md-flex__cell--stretch"><div class="md-flex__ellipsis md-header-nav__title" data-md-component="title"><span class="md-header-nav__topic">Blog</span><span class="md-header-nav__topic">CockroachDB 中的 JOIN</span></div></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--search md-header-nav__button" for="__search"></label><div class="md-search" data-md-component="search" role="dialog"><label class="md-search__overlay" for="__search"></label><div class="md-search__inner" role="search"><form class="md-search__form" name="search"><input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active"> <label class="md-icon md-search__icon" for="__search"></label> <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button></form><div class="md-search__output"><div class="md-search__scrollwrap" data-md-scrollfix><div class="md-search-result" data-md-component="result"><div class="md-search-result__meta">键入以开始搜索</div><ol class="md-search-result__list"></ol></div></div></div></div></div></div></div></nav></header><div class="md-container"><main class="md-main"><div class="md-main__inner md-grid" data-md-component="container"><div class="md-sidebar md-sidebar--primary" data-md-component="navigation"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--primary" data-md-level="0"><label class="md-nav__title md-nav__title--site" for="__drawer"><a href="https://iswade.github.io/" title="Blog" class="md-nav__button md-logo"><img src="../../../themes/me.jpg" width="48" height="48"></a>Blog</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../.." title="Home" class="md-nav__link">Home</a></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2"><label class="md-nav__link" for="nav-2">Database</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-2">Database</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../../articles/pebble/" title="pebble kv存储引擎" class="md-nav__link">pebble kv存储引擎</a></li><li class="md-nav__item"><a href="../../faunadb_transaction/" title="FaunaDB的分布式事务协议" class="md-nav__link">FaunaDB的分布式事务协议</a></li><li class="md-nav__item"><a href="../../Aurora/" title="Aurora如何设计云原生关系数据库" class="md-nav__link">Aurora如何设计云原生关系数据库</a></li><li class="md-nav__item"><a href="../../btree_vs_lsmtree/" title="现代存储系统背后的算法" class="md-nav__link">现代存储系统背后的算法</a></li><li class="md-nav__item"><a href="../../../notes/db_nodes/00_database_systems_2018/" title="数据库笔记" class="md-nav__link">数据库笔记</a></li><li class="md-nav__item"><a href="../../F1_query/" title="F1 Query" class="md-nav__link">F1 Query</a></li><li class="md-nav__item"><a href="../../../articles/partition/" title="数据分区" class="md-nav__link">数据分区</a></li><li class="md-nav__item"><a href="../../../articles/boltdb/" title="Bolt 数据库" class="md-nav__link">Bolt 数据库</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3"><label class="md-nav__link" for="nav-3">Distribute</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-3">Distribute</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../distsys/" title="分布式系统大纲" class="md-nav__link">分布式系统大纲</a></li><li class="md-nav__item"><a href="../../strong_consistency_models/" title="强一致性模型" class="md-nav__link">强一致性模型</a></li><li class="md-nav__item"><a href="../../zookeeper/" title="Zookeeper" class="md-nav__link">Zookeeper</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4"><label class="md-nav__link" for="nav-4">Language</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-4">Language</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../../articles/go_concurrency/" title="Go 并发编程" class="md-nav__link">Go 并发编程</a></li><li class="md-nav__item"><a href="../../go_interface/" title="如何使用 Go 接口" class="md-nav__link">如何使用 Go 接口</a></li></ul></nav></li><li class="md-nav__item md-nav__item--nested"><input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5"><label class="md-nav__link" for="nav-5">Engineering</label><nav class="md-nav" data-md-component="collapsible" data-md-level="1"><label class="md-nav__title" for="nav-5">Engineering</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="../../../advanced_markdown/" title="高级markdown" class="md-nav__link">高级markdown</a></li><li class="md-nav__item"><a href="../../linux_sysadmin/" title="linux 系统管理" class="md-nav__link">linux 系统管理</a></li><li class="md-nav__item"><a href="../../../notes/git/" title="git 入门教程" class="md-nav__link">git 入门教程</a></li><li class="md-nav__item"><a href="../../to_be_manager/" title="How to be a manager" class="md-nav__link">How to be a manager</a></li></ul></nav></li><li class="md-nav__item"><a href="../../../about/" title="About" class="md-nav__link">About</a></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component="toc"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--secondary"><label class="md-nav__title" for="__toc">目录</label><ul class="md-nav__list" data-md-scrollfix><li class="md-nav__item"><a href="#_1" title="早期实现" class="md-nav__link">早期实现</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#_2" title="在引擎之下" class="md-nav__link">在引擎之下</a></li><li class="md-nav__item"><a href="#join" title="第一版 JOIN 带来了什么？" class="md-nav__link">第一版 JOIN 带来了什么？</a></li><li class="md-nav__item"><a href="#_3" title="下一步：性能优化" class="md-nav__link">下一步：性能优化</a></li><li class="md-nav__item"><a href="#_4" title="关于特性的说明" class="md-nav__link">关于特性的说明</a></li><li class="md-nav__item"><a href="#_5" title="结束语" class="md-nav__link">结束语</a></li></ul></nav></li><li class="md-nav__item"><a href="#joins" title="更好的 JOINs 在路上" class="md-nav__link">更好的 JOINs 在路上</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#_6" title="六个月的发展" class="md-nav__link">六个月的发展</a></li><li class="md-nav__item"><a href="#_7" title="抽象查询语义" class="md-nav__link">抽象查询语义</a></li><li class="md-nav__item"><a href="#join_1" title="优化 JOIN 算子" class="md-nav__link">优化 JOIN 算子</a></li><li class="md-nav__item"><a href="#_8" title="优化查询过滤" class="md-nav__link">优化查询过滤</a></li><li class="md-nav__item"><a href="#_9" title="删除未使用的列" class="md-nav__link">删除未使用的列</a></li><li class="md-nav__item"><a href="#_10" title="分布式查询执行和并行化" class="md-nav__link">分布式查询执行和并行化</a></li><li class="md-nav__item"><a href="#2017" title="2017年及以后的计划" class="md-nav__link">2017年及以后的计划</a></li></ul></nav></li><li class="md-nav__item"><a href="#join_2" title="Join 的顺序" class="md-nav__link">Join 的顺序</a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a href="#_11" title="一些词汇" class="md-nav__link">一些词汇</a></li><li class="md-nav__item"><a href="#join_3" title="优化 JOIN" class="md-nav__link">优化 JOIN</a></li></ul></nav></li></ul></nav></div></div></div><div class="md-content"><article class="md-content__inner md-typeset"><h1 id="cockroachdb-join">CockroachDB 中的 JOIN</h1>
<h2 id="_1">早期实现</h2>
<p>第一版花费了一年时间来完成。</p>
<p>可以正常工作，但是没有任何优化。可能会导致导致服务器因为 OOM 而停止。</p>
<p>这里主要介绍为什么是这样，后续我们会做什么。</p>
<p>当然，更好的 JOIN 在规划之中。会有 V2，V3 甚至更长远的版本。我们首先在这里提供了 JOIN 操作，重要的一点就是建立一个基线。一个用于测试、实验和性能测试的基线。即使这个实现不适合在生产环境中使用，当前把它包含进来，我们能够保证未来可以被测试和维护，这样我们就能致力于改进和扩展它。</p>
<h3 id="_2">在引擎之下</h3>
<p>第一次实现的主要冬季是在测试期间充当基准基线。 在准备开始之前，我们的目标是提供正确结果行的最简单、最自然的实现，故意忽略了过去40年来关于如何执行快速 JOIN 的数据库研究。</p>
<p>这种方法的一个优点是手动分析和验证相当简单。另一个优点是它也很容易显示和解释！算法是：读取 JOIN 操作的右边的所有行到内存中，读取一行左表的数据，查找在内存中右边的相应的行，如果结果是匹配的，则产生一行 JOIN 的结果。当找不到匹配时，一些额外条件处理由 OUTER JOIN 产生的 NULL 行。</p>
<p>这段代码中唯一允许聪明的是使它更简单：当查询指定RIGHT OUTER JOIN时，我们交换操作数并使用LEFT OUTER JOIN的逻辑运行它。</p>
<p>这一次，我们为简单性做了优化，对性能没有任何优化。具体地说，给定左操作数中的N行和右操作数中的M，单个JOIN的时间复杂度现在为 <code class="codehilite">O(N×M)</code>，因此 <strong>自连接为</strong> 二次，空间开销为 <code class="codehilite">O(M)</code>。这远不是适度优化的有序连接的常规线性时间复杂度，或者是使用键或索引连接时的恒定空间开销。 简而言之，除非您的 JOIN 右操作数的行数非常少，否则您可能不希望将其用于生产工作负载。</p>
<h3 id="join">第一版 JOIN 带来了什么？</h3>
<p>通过支持SQL JOIN，我们使开发人员能够使用CockroachDB跟踪许多现有的SQL教程和课程。它可以对CockroachDB进行更多样化的评估，并为 <strong>学习</strong> 和修补创造更丰富的环境。</p>
<p>对于我们内部，它为 <strong>测试</strong> 期间的比较提供了基础。 我们无法轻松地重用其他数据库中的现有JOIN测试，因为我们的输入系统略有不同，他们的测试/参考查询与CockroachDB的行为完全不同。 所以我们准备这个版本来构建我们自己的测试。</p>
<p>对我们的用户还有另一个优势。 在2016年的剩余时间里，我们的目标是增加CockroachDB 与流行的 ORM 之间的兼容性。 这些 ORM 大量使用数据库自我检查机制，使用 JOIN 查询 信息模式 以推断表结构。 我们第一次实现 JOIN 将实现 ORM 兼容性。 <strong>信息模式</strong> 主要包含小表，性能不是一个重要的问题。</p>
<h3 id="_3">下一步：性能优化</h3>
<p>我们对CockroachDB的整体实施策略是从对我们的用户最有用的SQL功能开始。换句话说，我们希望版本1.0中的JOIN对于 <strong>最常见的用例</strong> 来说相当快。</p>
<p>在OLTP应用程序中，我们看到大多数请求都会加入带有类别的产品，带税率的价格，带有组织的客户等。这些用例的共同特征是 <strong>连接列是主键或具有索引</strong> 。 这就是我们计划首先进行优化的地方：<strong>使用来自JOIN操作数的排序信息，并将操作的时间复杂度降低到线性。</strong></p>
<p>从那时起，我们还将开始应用一些最先进的数据库理论。 对于数据库不为连接数据提供本机排序的情况，我们将执行 <strong><a href="https://en.wikipedia.org/wiki/Sort-merge_join">排序和合并</a></strong> 而不是 <strong>嵌套循环</strong>，并在磁盘上准备排序数据，而不是将其全部保存在不适合的内存中。 不久，<strong><a href="https://en.wikipedia.org/wiki/Hash_join">散列连接</a></strong> 也将很快出现在CockroachDB中。</p>
<p>结合正在实现的 <strong>分布式查询执行</strong> 引擎来实现并行执行。</p>
<p>除此之外，我们将在了解用户喜欢如何使用CockroachDB时进行优化。 在我们知道哪些适用于我们的用户想要在分布式数据库中抛出的工作负载之前，我们认为已经开始实现经典优化是不明智的。 我们怀疑我们可能需要为 CockroachDB 开发新类型的优化，因为 <strong>瓶颈不会出现在与传统 RDBM 相同的地方</strong>。</p>
<h3 id="_4">关于特性的说明</h3>
<p>兼容 PostgreSQL 需要很长的时间。SQL 支持还不到10人年，PostgreSQL 大约有100人年。此外，我们目前正在 CockroachDB 内部花费大量时间来稳定并保证可扩展性；现在使我们的SQL前端变得更大会对核心技术的生产性工作产生惯性。</p>
<p>此外，我们对CockroachDB 1.0版的目标是该产品可以支持围绕OLTP工作负载构建的新业务和项目。</p>
<p>例如相关的子查询，这些子查询在应用程序代码中不常见（它们可以被许多工作负载中的 JOIN 替换）。 然而，我们承认它们使开发人员的生活更轻松。 通过适当的性能优化支持它们将使更多教程/课程示例能够立即与 CockroachDB 一起使用。 所以这也将及时到达 CockroachDB。</p>
<h3 id="_5">结束语</h3>
<p>在决定支持SQL的这一周年之际，JOIN被添加到CockroachDB中。 第一个实现简单明了; 它可能很慢并且需要大量内存，但它的目的是为了特定的。 我们已经开始研究1.0的更好的算法。</p>
<p>当然，我们可以将这个简单的实现保留给自己，仅用于内部测试。 或者我们可以在没有任何文档的情况下进行发布，但那不是我们的方式。 我们致力于保持我们的进步对社区的透明度。 这就是我们现在所处的位置，从现在开始，我们可以做得更好。</p>
<h2 id="joins">更好的 JOINs 在路上</h2>
<p>六个月前，我们给出了第一个 JOIN 实现版本。</p>
<p>如果你对前面版本的 JOIN 使用动力不足，可以使用一下 CRDB 1.0 的版本。</p>
<p>这篇博客文章是关于CockroachDB中 JOIN 的下一章。 在本章中，您将了解 JOIN 查询执行现在的工作原理，您现在可以执行的操作以及之前无法执行的操作，以及您在v1.0中可以获得的功能。 最后，我们将查看有关SQL优化的路线图。</p>
<h3 id="_6">六个月的发展</h3>
<p>概括一下：</p>
<ul>
<li>使用 <strong>hash join</strong> 替代了默认的实现，这在大多数情况下将大小为N和M的两个输入表的渐近时间复杂度改变为O(N + M) 而不是先前的O(N×M) - 线性加速。</li>
<li>我们已就 <strong>条件过滤</strong> 优化做了一些初步工作，这导致许多简单连接被简化为恒定时间操作，而不是像以前那样代价很高的的平方查找。</li>
<li>我们有一些初步的工作代码来分发和<strong>并行化</strong>连接的执行。对于某些查询，这可以使群集大小的加速变为线性。</li>
</ul>
<h3 id="_7">抽象查询语义</h3>
<p>CockroachDB将每个SQL连接解释为二分操作。</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #008800; font-weight: bold">SELECT</span> * <span style="color: #008800; font-weight: bold">FROM</span> a, b, <span style="color: #008800; font-weight: bold">c</span>, <span style="color: #008800; font-weight: bold">WHERE</span> ...

<span style="color: #888888">-- 解释为</span>

<span style="color: #008800; font-weight: bold">SELECT</span> * <span style="color: #008800; font-weight: bold">FROM</span> ((a <span style="color: #008800; font-weight: bold">CROSS</span> <span style="color: #008800; font-weight: bold">JOIN</span> b) <span style="color: #008800; font-weight: bold">CROSS</span> <span style="color: #008800; font-weight: bold">JOIN</span> <span style="color: #008800; font-weight: bold">c</span>) <span style="color: #008800; font-weight: bold">WHERE</span> <span style="color: #a61717; background-color: #e3d2d2">…</span>
</pre></div>

<p>内部表示为：</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span>                        Render *
                           |
                          Join
                        /     \
                     Join      c
                    /  \
                   a    b
</pre></div>

<p>此整体解释尚未更改：CockroachDB当前以查询指定的逻辑顺序处理联接，并且用户可以完全控制 JOIN 的顺序。 （当然，这种控制的另一面是，如果用户没有考虑连接顺序，结果可能是低效的。稍后会详细介绍。）</p>
<p>除了SELECT的数据操作数的这种通用结构之外，CockroachDB必须根据WHERE子句过滤掉行。</p>
<p>直到最近，下面形式的查询：</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #008800; font-weight: bold">SELECT</span> * <span style="color: #008800; font-weight: bold">FROM</span> abc <span style="color: #008800; font-weight: bold">WHERE</span> abc.x &gt; <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #008800; font-weight: bold">AND</span> abc.y &lt; <span style="color: #0000DD; font-weight: bold">2</span>
</pre></div>

<p>还被按如下形式处理：</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span>               Render *
                 |
               Filter on abc.x &gt; 3 AND abc.y &lt; 2
                 |
                abc
</pre></div>

<p>这意味着与联接组合时我们遇到以下情况：一个如下形式的查询：</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #008800; font-weight: bold">SELECT</span> *
  <span style="color: #008800; font-weight: bold">FROM</span> a, b, <span style="color: #008800; font-weight: bold">c</span>
 <span style="color: #008800; font-weight: bold">WHERE</span> a.x = b.x <span style="color: #008800; font-weight: bold">AND</span> b.y = <span style="color: #008800; font-weight: bold">c</span>.y <span style="color: #008800; font-weight: bold">AND</span> a.x+b.y+<span style="color: #008800; font-weight: bold">c</span>.z &gt; <span style="color: #0000DD; font-weight: bold">0</span>
</pre></div>

<p>会以如下形式处理</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span>                    Render *
                      |
                Filter on a.x = b.x AND b.y = c.y
                          AND a.x+b.y+c.z &gt; 0
                      |
                     Join
                   /     \
                Join      c
               /  \
              a    b
</pre></div>

<p>这意味着在我们决定向客户端报告哪些行之前，需要计算CROSS JOIN b CROSS JOIN c的整个交叉连接结果。即使对于小输入表，这也可能在存储器中产生极大的中间结果集 - 例如在产生任何结果之前，在每个100行的小表之间进行简单的5向连接将在内存中产生100亿行！</p>
<p>这很愚蠢，因为上面的查询真正意图的更像是：</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span>                    Render *
                      |
                Filter on a.x+b.y+c.z &gt; 0
                      |
                    Join on b.y = c.y
                   /               \
             Join on a.x = b.x      c
               /  \
              a    b
</pre></div>

<p>像这样处理查询显然会大大减少中间行的数量。我们需要以某种方式到达这里，到达那里的过程就是我们在接下来的部分中描述的内容。</p>
<h3 id="join_1">优化 JOIN 算子</h3>
<p>因此，在秋季，我们敬爱的合作社和同事Irfan Sharif提供了基于经典散列连接算法的替代实现：第一个表的结果被加载到用连接列键入的哈希表中。 然后扫描第二个表，并在每一行查找哈希表以查看是否存在匹配。 与初始代码的线性查找相比，哈希表查找以分摊的常量时间运行，因此获得了巨大的加速。</p>
<p>因为散列连接在概念上仅为equijoins定义（当连接列上两个输入行成对相等时结果存在的连接），这个新算法最初仅针对使用USING或NATURAL定义的连接激活，其中查询强制要求相等 句法。 不久之后，我们能够在使用ON语法时检测相等表达式，并为它们使用散列连接。</p>
<p>旁注：SQL数据库实现者之间的常见习惯是在尝试使 <strong>外连接正常工作</strong> 时遇到麻烦和不适。 例如，PostgreSQL在1996年的第一个版本中支持内连接，但在2001年才开始支持外连接。我们也遇到了麻烦，我们不得不再次修复我们的外连接实现。 希望外部连接在CockroachDB中起作用，但是在我们的其余实现进一步成熟之前，它们不会得到优化的关注。</p>
<h3 id="_8">优化查询过滤</h3>
<p>我们看到的第二件事是减少连接操作的强度：提供了多少行作为散列连接算法的输入。为此，我们观察到许多查询指定了一个WHERE子句，该子句缩小了结果行，但是这个WHERE子句同样可以在连接之前应用，而不是之后应用。</p>
<div class="codehilite" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #008800; font-weight: bold">SELECT</span> * <span style="color: #008800; font-weight: bold">FROM</span> a,b <span style="color: #008800; font-weight: bold">WHERE</span> a.x = b.x
<span style="color: #888888">--等价于</span>
<span style="color: #008800; font-weight: bold">SELECT</span> * <span style="color: #008800; font-weight: bold">FROM</span> (a <span style="color: #008800; font-weight: bold">JOIN</span> b <span style="color: #008800; font-weight: bold">USING</span>(x))

<span style="color: #008800; font-weight: bold">SELECT</span> * <span style="color: #008800; font-weight: bold">FROM</span> a, b <span style="color: #008800; font-weight: bold">WHERE</span> a.y &gt; <span style="color: #0000DD; font-weight: bold">3</span> <span style="color: #008800; font-weight: bold">AND</span> b.z &lt; <span style="color: #0000DD; font-weight: bold">4</span> <span style="color: #008800; font-weight: bold">AND</span> a.x = b.x
<span style="color: #888888">--等价于</span>
<span style="color: #008800; font-weight: bold">SELECT</span> *
   <span style="color: #008800; font-weight: bold">FROM</span> (<span style="color: #008800; font-weight: bold">SELECT</span> * <span style="color: #008800; font-weight: bold">FROM</span> a <span style="color: #008800; font-weight: bold">WHERE</span> a.y &gt; <span style="color: #0000DD; font-weight: bold">3</span>) <span style="color: #008800; font-weight: bold">AS</span> a
        <span style="color: #008800; font-weight: bold">JOIN</span>
        (<span style="color: #008800; font-weight: bold">SELECT</span> * <span style="color: #008800; font-weight: bold">FROM</span> b <span style="color: #008800; font-weight: bold">WHERE</span> b.z &lt; <span style="color: #0000DD; font-weight: bold">4</span>) <span style="color: #008800; font-weight: bold">AS</span> b
        <span style="color: #008800; font-weight: bold">USING</span> (x)
</pre></div>

<p>将原始查询转换为后者，等效查询是称为“选择传播”的更大类优化的实例。这个想法源于关系代数，其中SQL查询的各种数据处理阶段仅使用基本构建块（如投影，选择，连接等）表示为公式。理论解释了大多数执行某些操作的查询（例如，连接） ），然后一个选择，（一个WHERE过滤器）可以总是被重写以首先进行选择，然后是其余的 —— 据说选择与大多数其他关系运算符是 <strong>可交换</strong> 的 —— 并且这种转换总是会降低其他运算符的强度，因此总是令人满意的。</p>
<p>因此，在2016年的最后一个季度，我们在CockroachDB中实现了这一优化，现在它已被激活（但不限于）内连接。</p>
<p>完成此操作后，也会自动激活一个直接好处：当WHERE过滤器向下“向下传播”查询中的连接时，它们将作为对表操作数的查找的约束变为可见，因此对于索引选择和 K/V 查找范围生成。</p>
<p>感谢现有优化的偶然组合，现在，通过使用索引和指向KV查找来访问各个表操作数的能力，加速了联接。</p>
<h3 id="_9">删除未使用的列</h3>
<h3 id="_10">分布式查询执行和并行化</h3>
<p>当CockroachDB分发连接时，它会在多个节点上同时并行地加载来自两个表操作数的数据，在群集的 <strong>不同节点上执行连接的多个部分</strong> ，然后将结果合并到从客户端接收查询的节点。 这样，理论上可以通过簇的大小线性因子（在理想情况下）加速连接。</p>
<p>现在要说的是，除了传统的优化之外，分布式查询执行将成为CockroachDB进一步加速连接执行的主要工具之一。</p>
<h3 id="2017">2017年及以后的计划</h3>
<p>我们上面提到的优化被称为“本地”，因为它们可以通过查看查询的一小部分的结构来决定，而不考虑查询的整体结构，也不考虑数据库模式，也不考虑存储在中的数据的统计信息。</p>
<p>我们正在计划一些额外的局部优化，例如在操作数被适当排序时使用<strong>合并连接</strong>，但我们的注意力将立即增长到更大的范围。</p>
<p>SQL查询优化的最新技术是根据当前可用的索引和操作数表中值的当前基数（连接列中的不同值的数量）重新排序连接操作。这是成熟和企业SQL数据库发现其性能优势的地方，我们打算投入精力来做同样的事情。</p>
<p>我们最近遇到的一个特殊灵感来源是Victor Leis等人的文章“<a href="http://www.vldb.org/pvldb/vol9/p204-leis.pdf">How Good are Query Optimizers, Really?  by Victor Leis et al.</a>”。去年在VLDB（超大型数据库）会议的会议记录中发表。本文不仅强调了我们可以用来与竞争对手进行公平比较的一些指标;它还指出了当前流行的和可能有用的行业基准以及它们应用中的有趣缺陷。特别是，由于他们的 <a href="https://github.com/gregrahn/join-order-benchmark">JOIN Order Benchmack</a>，我们现在感觉更有能力支持和评估我们在加入优化方面的持续努力。</p>
<h2 id="join_2">Join 的顺序</h2>
<p>关系模型的发展预示着数据库世界向前迈出了一大步。 几年后，SQL为数据操作引入了丰富的词汇：过滤器，投影，以及最重要的 —— 强大的连接。 JOIN 意味着分析师可以构建新的报告而无需与工程中的那些人交往，但更重要的是，复杂的连接查询的存在意味着理论家们在接下来的五十年中有一个有趣的新 NP-hard 问题。</p>
<p>从那以后，连接一直是基于简单“关系”构造复杂查询的基本操作。 SQL的声明性质意味着用户通常不会指定如何执行查询 —— 这是数据库的一个单独组件的工作，称为优化器来解决这个问题。 由于JOIN在此类查询中非常普遍，因此优化程序必须特别注意以智能方式处理它们。 正如我们所看到的，这不是一项微不足道的任务。</p>
<p>在这篇文章中，我们将看看为什么连接排序如此重要，并培养一种如何思考问题空间的感觉。 然后，在即将发布的帖子中，我们将开始讨论实现快速，可靠算法以产生良好连接顺序的方法。</p>
<h3 id="_11">一些词汇</h3>
<ol>
<li>两个表的乘积：<span><span class="MathJax_Preview">A\times B</span><script type="math/tex">A\times B</script></span></li>
<li>关系 <span><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>  的过滤 <span><span class="MathJax_Preview">\sigma_p(R)</span><script type="math/tex">\sigma_p(R)</script></span> ，</li>
<li>关联关系可以写成 <span><span class="MathJax_Preview">\sigma_p(A\times B)</span><script type="math/tex">\sigma_p(A\times B)</script></span> ，我们通常将 join 操作作为一个独立的单元，所以也可以写成 <span><span class="MathJax_Preview">A\bowtie_p B</span><script type="math/tex">A\bowtie_p B</script></span></li>
<li>可交换性 <span><span class="MathJax_Preview">A\times B = B\times A</span><script type="math/tex">A\times B = B\times A</script></span>，以及 <span><span class="MathJax_Preview">A\bowtie_p B = B\bowtie_p A</span><script type="math/tex">A\bowtie_p B = B\bowtie_p A</script></span></li>
<li>可以通过乘积 <strong>上拉</strong> 过滤条件: <span><span class="MathJax_Preview">\sigma_p(A)\times B = \sigma_p(A\times B)</span><script type="math/tex">\sigma_p(A)\times B = \sigma_p(A\times B)</script></span></li>
</ol>
<h3 id="join_3">优化 JOIN</h3>
<p>所以我们可以按照任何顺序执行连接。 这提出了一个问题：是否有一些顺序比另一种顺序更合适？ 是。 事实证明，我们执行连接的顺序可能导致所需的工作量大不相同。</p>
<p>过滤掉一半行的选择度是 0.5。过滤掉一百行中的一行的选择度是0.01。</p>
<p>不同 JOIN 对结果集的大小影响不同，选择度越高，结果集越少，需要优先执行。</p></article></div></div></main><footer class="md-footer"><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class="md-footer-copyright"><div class="md-footer-copyright__highlight">Copyright &copy; 2016 - 2019 iswade</div>powered by <a href="https://www.mkdocs.org">MkDocs</a> and <a href="https://squidfunk.github.io/mkdocs-material/">Material for MkDocs</a></div></div></div></footer></div><script src="../../../assets/javascripts/application.d5a09f94.js"></script><script src="../../../assets/javascripts/lunr/lunr.stemmer.support.js"></script><script src="../../../assets/javascripts/lunr/tinyseg.js"></script><script src="../../../assets/javascripts/lunr/lunr.ja.js"></script><script>app.initialize({version:"1.0.4",url:{base:"../../.."}})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>