



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
        <link rel="canonical" href="https://iswade.github.io/translate/crdb/crdb_query_planning/">
      
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="jp">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\uff0c\u3002]+">
      
      <link rel="shortcut icon" href="../../../images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-3.1.0">
    
    
      
        <title>SQL 查询计划 - iswade</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/application.11e41852.css">
      
        <link rel="stylesheet" href="../../../assets/stylesheets/application-palette.22915126.css">
      
      
        
        
        <meta name="theme-color" content="">
      
    
    
      <script src="../../../assets/javascripts/modernizr.20ef595d.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../../assets/fonts/material-icons.css">
    
    
      <link rel="stylesheet" href="../../../themes/extra.css">
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="white" data-md-color-accent="red">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#sql" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://iswade.github.io/" title="iswade" class="md-header-nav__button md-logo">
          
            <img src="../../../images/me.jpg" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                iswade
              </span>
              <span class="md-header-nav__topic">
                SQL 查询计划
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://iswade.github.io/" title="iswade" class="md-nav__button md-logo">
      
        <img src="../../../images/me.jpg" width="48" height="48">
      
    </a>
    iswade
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../../.." title="首页" class="md-nav__link">
      首页
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      数据库
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        数据库
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../notes/db_nodes/00_database_systems_2018/" title="数据库笔记" class="md-nav__link">
      数据库笔记
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../F1_query/" title="F1 Query" class="md-nav__link">
      F1 Query
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../articles/partition/" title="数据分区" class="md-nav__link">
      数据分区
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../articles/boltdb/" title="Bolt 数据库" class="md-nav__link">
      Bolt 数据库
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      分布式
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        分布式
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../strong_consistency_models/" title="强一致性模型" class="md-nav__link">
      强一致性模型
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../zookeeper/" title="Zookeeper" class="md-nav__link">
      Zookeeper
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      编程语言
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        编程语言
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../articles/go_concurrency/" title="Go 并发编程" class="md-nav__link">
      Go 并发编程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../go_interface/" title="如何使用 Go 接口" class="md-nav__link">
      如何使用 Go 接口
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      工具
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        工具
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../linux_sysadmin/" title="linux 系统管理" class="md-nav__link">
      linux 系统管理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../notes/git/" title="git 入门教程" class="md-nav__link">
      git 入门教程
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      其它
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        其它
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../to_be_manager/" title="How to be a manager" class="md-nav__link">
      How to be a manager
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../../about/" title="关于" class="md-nav__link">
      关于
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="sql">SQL 查询计划</h1>
<h1 id="_1">概要</h1>
<p>此RFC描绘了SQL查询计划的高级模块的概要，包括功能齐全的优化器。</p>
<h1 id="_2">动机</h1>
<p>SQL 查询计划涉及将 SQL 查询的 AST 转换为用于执行的物理查询计划。直接执行 SQL 查询可能会非常慢，因为 SQL 指定了所需的结果而不是如何实现。给定的 SQL 查询可能有数千个查询计划，执行时间差异很大。用于生成和选择良好的查询计划的技术涉及重要的的 <strong>工程挑战</strong>。</p>
<p>此RFC旨在为SQL优化器的短期和长期工作提供指导，并给出当前系统需要重点演变的部分。</p>
<h1 id="_3">指导说明</h1>
<h2 id="_4">概述</h2>
<p>SQL 查询计划通常以下面的8个模块来描述。</p>
<ol>
<li><a href="#stats">Stats</a></li>
<li><a href="#prep">Prep</a></li>
<li><a href="#rewrite">Rewrite</a></li>
<li><a href="#memo">Memo</a></li>
<li><a href="#cost-model">Cost Model</a></li>
<li><a href="#search-aka-enumeration">Search</a></li>
<li><a href="#properties">Properties</a></li>
<li><a href="#transformations">Transformations</a></li>
</ol>
<p>Stats、Cost Model、Memo、Properties 和 Transformations 可以被认为是模块，Prep、Rewrite 和 Search 可以被认为是阶段，虽然为了统一期间在这个文档中都称之为模块。Memo（备忘录）是一种紧凑地表示搜索期间生成的树木的森林的技术。Stats、Properties、Cost Model 和 Transformations 是用于支撑 Prep、Rewrite 和 Search 的模块。</p>
<div class="codehilite"><pre><span></span>                   SQL query text
                         |
                   +-----v-----+
                   |   Parse   |
                   +-----+-----+
                         |
                       (ast)
                         |
     +-------+     +-----v-----+    - 常量折叠, 类型检查, 名称解析
     | Stats +-----&gt;   Prep    |    - 计算初始的属性
     +-------+     +-----+-----+    - 检索并附加统计(Stats)数据
                         |          - 每个 PREPARE 做一次
                      (expr)  
                         |  
                   +-----v-----+    - 获取占位符值 / 时间戳
                +--&gt;  Rewrite  |    - 代价无关的转换, 例如、谓词下推
+------------+  |  +-----+-----+    - 每个 EXECUTE 做一次
| Transforms +--+        |  
+------------+  |     (expr)  
                |        |  
                +--&gt;-----v-----+    - 基于代价的转换
+------------+     |  Search   |    - 找到最小代价的物理计划
| Cost Model +-----&gt;-----+-----+    - 包括 DistSQL 物理计划
+------------+           |
                  (physical plan)
                         |
                   +-----v-----+
                   | Execution |
                   +-----------+
</pre></div>

<p>除了 Stats 和 Memo 之外，CockroachDB 已经实现了这些模块的一部分。 例如，ockroachDB 执行名称解析和类型检查，它是Prep 的一部分，并在连接时执行谓词下推，在传统数据库中通常在重写阶段。 CockroachDB在索引选择期间（搜索的一部分）使用原始成本模型来根据过滤器和所需顺序选择要使用的索引。</p>
<p>除了8个模块，优化器的其它方面需要讨论的就是测试和测试基础设施。</p>
<p>最后，一个目的路标被提出，如何将这些工作分解在后面的几个发布中。</p>
<h2 id="_5">词汇表</h2>
<h2 id="_6">模块</h2>
<h3 id="prep">Prep</h3>
<p><em>Prep</em> （是 prepare 的缩写）是查询优化的第一个阶段，将 AST 转换为更加适合优化的形式，注释信息等后面阶段会被使用。Prep 包括解析表和列的应用（例如，名称解析）和类型检查，这些都已经在 CockroachDB 中做了。</p>
<p>在 Prep 中，将解析阶段的原始输出 AST 转换成表达式“树”。</p>
<p><div class="codehilite"><pre><span></span><span class="kd">type</span> <span class="nx">operator</span> <span class="kt">int16</span>
<span class="kd">type</span> <span class="nx">expr</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">op</span>              <span class="nx">operator</span>
  <span class="nx">children</span>        <span class="p">[]</span><span class="o">*</span><span class="nx">expr</span>
  <span class="nx">relationalProps</span> <span class="o">*</span><span class="nx">relationalProps</span> 
  <span class="nx">scalarProps</span>     <span class="o">*</span><span class="nx">scalarProps</span>    
  <span class="nx">physicalProps</span>   <span class="o">*</span><span class="nx">physicalProps</span>   
  <span class="nx">private</span>         <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
这里的术语 <em>“表达式”</em> 基于文献中的用法，但由于当前的SQL代码使用“表达式”来引用标量表达式，因此它有点令人困惑。 在本文档中，“表达式”指的是关系表达式或标量表达式。 对表达式使用统一节点类型有助于在优化的重写和搜索阶段使用的变换。</p>
<p>每个表达式有操作符和零个或者更多操作数（<code class="codehilite">expr.children</code>）。操作符可以是 <em>关系的</em> （例如 join）或者 <em>标量</em> （例如 &lt;）。关系操作符可以是逻辑（仅指定结果）或者物理（指定结果和特殊的实现）。</p>
<p>在 Prep 所有的列都有一个唯一的索引（数字）。列编号涉及为查询中的每个基本列和非平凡投影分配唯一的查询特定索引。</p>
<p>为每列提供唯一索引允许上面提到的表达式节点使用位图跟踪输入和输出列，或实际上在准备阶段和后续阶段中的任何列集。位图表示允许快速确定表达式节点之间的兼容性，并且在重写和变换期间利用位图表示来确定这种操作的合法性。</p>
<p>Prep 阶段还计算 <em>逻辑属性</em>，例如每个表达式，子表达式的输入和输出列，等价列，非空列和功能依赖。</p>
<p>一个表达式的功能依赖是对一个或者多个列集的约束。功能依赖的特殊的例子是投影，1个或者多个输入列决定一个输出列，而“键”是一组列，其中表达式输出的两行在投影到该集合之后是相等的（例如，唯一的 所有列都为NOT NULL的表的索引。 从概念上讲，功能依赖关系形成一个图形，尽管它们在代码中没有表示。</p>
<h3 id="rewrite">Rewrite</h3>
<p>查询优化的第二个阶段是 <em>rewrite</em>。重写阶段执行对逻辑查询树的转换。</p>
<p>转换将一个或者查询的部分的转换为另一个。需要注意的是与 Search 阶段有重叠性。两个阶段都是转换，但是 Search 需要跟踪并且对可选计划进行代价估计，但是重写不需要。在重写阶段的特殊上下文中，转换通常叫做 <em>rewrites</em>。</p>
<p>在重写期间，一个表达式的前一个版本被丢弃。在 Search 阶段，原始和新表达式都是并排保存的作为可选。</p>
<p>需要注意的是，转换中的一些在重写阶段执行的不需要再 Search 阶段重新执行。搜索的绝大部分转换都不是重写需要的。</p>
<p>重写阶段中，相关子查询“去相关”（同义词：“消除嵌套”），推断出其他谓词，谓词下推，各种对关系代数树的转换（例如，投影和连接消除）。例如谓词下推，考虑下面的查询：</p>
<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">USING</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span>
</pre></div>

<p>朴素的对这个查询的执行时获取所有的 a 和 b 的行，在 x 上连接（过滤）它们，然后再次执行过滤 <code class="codehilite">a.x &lt; 10</code> 。谓词下推尝试下推谓词 <code class="codehilite">a.x &lt; 10</code> 在连接下面。这显然可以做到对 a 的扫描：</p>
<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">a</span> <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">),</span> <span class="n">b</span> <span class="k">USING</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<p>稍微复杂一点，我们也可以生成一个新的谓词使用功能依赖 <code class="codehilite">a.x = b.x</code> :</p>
<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">a</span> <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">),</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">b</span> <span class="k">WHERE</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="k">USING</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<p>谓词推断有助于谓词下推。考虑下面的查询：</p>
<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">USING</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<p>根据连接条件，我们可以推断出 <code class="codehilite">a.x IS NOT NULL</code> 并且 <code class="codehilite">b.x IS NOT NULL</code>:</p>
<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">USING</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">AND</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span>
</pre></div>

<p>并且谓词下推可以将这些谓词下推：
<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">a</span> <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">),</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">b</span> <span class="k">WHERE</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">)</span> <span class="k">USING</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div></p>
<h3 id="stats">Stats</h3>
<h3 id="memo">Memo</h3>
<p>Memo 是用于有效存储查询计划森林的数据结构。概念上讲，memo 是一个有标识的等价类（称之为 <strong>groups</strong>）组成的集合，每个组包含了逻辑等价的表达式集合。虽然备忘录之外的表达式节点包含子表达式列表，但 memo表达式包含子组列表。</p>
<p>根据定义，一个组内的所有的 memo 表达式共享相同的 <em>逻辑属性</em>，一个在后面的章节中更加深入探讨的概念。memo 表达式结构映射了表达式结果：</p>
<div class="codehilite"><pre><span></span><span class="kd">type</span> <span class="nx">exprID</span> <span class="kt">int32</span>
<span class="kd">type</span> <span class="nx">groupID</span> <span class="kt">int32</span>

<span class="kd">type</span> <span class="nx">memoExpr</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">op</span>            <span class="nx">operator</span>
  <span class="nx">children</span>      <span class="p">[]</span><span class="nx">groupID</span>
  <span class="nx">physicalProps</span> <span class="o">*</span><span class="nx">physicalProps</span>
  <span class="nx">private</span>       <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">memoGroup</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">exprs</span>           <span class="p">[]</span><span class="nx">memoExpr</span>
  <span class="nx">relationalProps</span> <span class="o">*</span><span class="nx">relationalProps</span>
  <span class="nx">scalarProps</span>     <span class="o">*</span><span class="nx">scalarProps</span>
<span class="p">}</span>
</pre></div>

<p>在 memo 上的转换不是直接进行，因为转换操作在树上，而备忘录模拟森林。相反，表达式段从备忘录中提取，转换被重新插入备忘录中。乍一看这似乎是繁重且低效的，但是它允许更自然地重写转换，并且可以有效地执行表达式片段的提取。</p>
<p>通过称为 <em>binding</em> 的过程来执行用于转换的表达片段的提取。绑定允许迭代匹配以特定memo-expression为根的模式的所有表达式。使用要提取的相同表达式结构指定模式，并添加充当通配符的“pattern-leaf”和“pattern-tree”占位符：</p>
<ul>
<li>
<p><strong>模式叶</strong> 匹配任何一个表达式树，只有树的根保留在绑定表达式中。当变换使用表达式不透明时使用它。 换句话说，转换并不关心子树内的帽子。 从某种意义上说，它是一个“叶子”，它是任何与模式匹配的绑定中的叶子。</p>
</li>
<li>
<p><strong>模式树</strong> 匹配任何表达式树，并指示需要递归提取完整子树。 当转换需要对该表达式进行某些操作时，它通常用于标量表达式。 请注意，模式树会导致枚举所有可能的子树，但标量表达式通常没有多个子树（如果没有子查询，则只有一个子树）。 [TODO（彼得）：在标量上下文中如何处理子查询？ 迭代所有子查询表达式似乎不正确。 <code class="codehilite">opttoy</code>中有一个TODO来缓存<code class="codehilite">memoGroup</code>中的标量表达式。 需要进一步调查。]</p>
</li>
</ul>
<p>为了更好地理解 memo 的结构：</p>
<div class="codehilite"><pre><span></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">WHERE</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span>
</pre></div>

<p>转换为表达式结构，该结构模拟查询的扩展关系代数：</p>
<div class="codehilite"><pre><span></span>inner-join [columns: a.x a.y b.x b.z]
  filters:
    eq
      inputs:
        variable (a.x)
        variable (b.x)
  inputs:
    scan [columns: a.x a.y]
    scan [columns: b.x b.z]
</pre></div>

<p>将表达式树插入到 memo 中结果如下：</p>
<div class="codehilite"><pre><span></span><span class="mi">6</span><span class="o">:</span> <span class="p">[</span><span class="n">inner</span><span class="o">-</span><span class="n">join</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span><span class="p">]]</span>
<span class="mi">5</span><span class="o">:</span> <span class="p">[</span><span class="n">eq</span> <span class="p">[</span><span class="mi">3</span> <span class="mi">4</span><span class="p">]]</span>
<span class="mi">4</span><span class="o">:</span> <span class="p">[</span><span class="n">variable</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">]</span>
<span class="mi">3</span><span class="o">:</span> <span class="p">[</span><span class="n">variable</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">]</span>
<span class="mi">2</span><span class="o">:</span> <span class="p">[</span><span class="n">scan</span> <span class="n">b</span><span class="p">]</span>
<span class="mi">1</span><span class="o">:</span> <span class="p">[</span><span class="n">scan</span> <span class="n">a</span><span class="p">]</span>
</pre></div>

<p>Memo 组在创建时标号，并对这些组进行拓扑排序以进行显示（这是一个实现细节，不是为了规定）。 在上面的示例中，每个组只包含一个memo-expression。 在执行连接交换变换之后，备忘录将扩展：</p>
<div class="codehilite"><pre><span></span><span class="mi">6</span><span class="o">:</span> <span class="p">[</span><span class="n">inner</span><span class="o">-</span><span class="n">join</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span><span class="p">]]</span> <span class="p">[</span><span class="n">inner</span><span class="o">-</span><span class="n">join</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">1</span> <span class="mi">5</span><span class="p">]]</span>
<span class="mi">5</span><span class="o">:</span> <span class="p">[</span><span class="n">eq</span> <span class="p">[</span><span class="mi">3</span> <span class="mi">4</span><span class="p">]]</span>
<span class="mi">4</span><span class="o">:</span> <span class="p">[</span><span class="n">variable</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">]</span>
<span class="mi">3</span><span class="o">:</span> <span class="p">[</span><span class="n">variable</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">]</span>
<span class="mi">2</span><span class="o">:</span> <span class="p">[</span><span class="n">scan</span> <span class="n">b</span><span class="p">]</span>
<span class="mi">1</span><span class="o">:</span> <span class="p">[</span><span class="n">scan</span> <span class="n">a</span><span class="p">]</span>
</pre></div>

<p>Memo 组包含逻辑等价的表达式，但是两个逻辑等价的表达式可能不会放到同一个 memo 组中。发生这种情况的原因是因为确定两个关系表达式逻辑等价100%正确很困难。正确性无法保证（即，当它们不是时，考虑两个逻辑等效的表达式）导致无效转换和无效计划。将两个逻辑上等效的表达式放在不同的组中有一个更温和的失败模式：备忘录和搜索效率较低。</p>
<p>一个表达式插入 memo 通过递归插入所有子表达式到 memo 中实现，然后对 memo 表达式计算一个 <strong>指纹</strong>。一个表达式的指纹是一个就是简单的表达式</p>
<p>通过将所有子表达式递归地插入到备忘录中然后计算用于备忘录表达式的**指纹**来执行将表达式插入到备忘录中。 memo-expression的指纹只是表达式运算符和子组列表。 例如，在上面的备忘录示例中，第一个内连接表达式的指纹是<code class="codehilite">[inner-join [1 2 5]]</code>。 备忘录维护从表达式指纹到备忘录组的映射，可以快速确定备忘录中是否已存在表达式片段。在计算备忘录表达式的组指纹时，执行少量特定于运算符的标准化。 例如，内连接的左输入和右输入按排序顺序输出，这导致表达式<code class="codehilite">[inner-join [1 2 5]]</code>和<code class="codehilite">[inner-join [2 1 5]]</code>具有同组指纹。 特定于运算符的规范化是保守的。 将逻辑等效表达式放在同一组中的常见情况是遵守变换表达式在逻辑上等效于其输入的不变量。</p>
<div class="codehilite"><pre><span></span><span class="kd">type</span> <span class="nx">memo</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="c1">// Map from memo-expression &quot;group&quot; fingerprint to group ID.</span>
  <span class="nx">groupMap</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">groupID</span>
  <span class="nx">groups</span>   <span class="p">[]</span><span class="nx">memoGroup</span>
<span class="p">}</span>
</pre></div>

<p>除了 memo 表达式，memo 组还包含期望的物理数学到组的优化状态的那些属性的映射。在 <a href="#search-aka-enumeration-or-transformation">Search</a> 中更详细讨论了这种状态。</p>
<p>通过组和表达式序号，在 memo 内的 <strong>location</strong> 标识了一个特定的 memo 表达式。当从备忘录中提取表达式片段时，每个“expr”都标记有它来自备忘录中的位置。这允许随后将转换的表达式重新插入到备忘录中以快速确定应该将表达式节点添加到哪些组。</p>
<p><div class="codehilite"><pre><span></span><span class="kd">type</span> <span class="nx">memoLoc</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">group</span> <span class="nx">groupID</span>
  <span class="nx">expr</span>  <span class="nx">exprID</span>
<span class="p">}</span>
<span class="o">...</span>
<span class="kd">type</span> <span class="nx">expr</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">op</span>  <span class="nx">operator</span>
  <span class="nx">loc</span> <span class="nx">memoLoc</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>
为了解释的目的，简化了备忘录结构的上述描述。 实际结构类似，但经过优化以减少分配。</p>
<h3 id="properties">Properties</h3>
<h3 id="computed-properties">Computed properties</h3>
<h3 id="transformations">Transformations</h3>
<h3 id="cost-model">Cost model</h3>
<h3 id="search-aka-enumeration">Search (a.k.a. Enumeration)</h3>
<h3 id="testing">Testing</h3>
<h2 id="roadmap">Roadmap</h2>
<h2 id="_7">未解决的问题</h2>
<h2 id="_8">附录</h2>
<h3 id="exprmemo">Expr/Memo 例子</h3>
<h3 id="_9"></h3>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright &copy; 2016 - 2019 iswade
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../assets/javascripts/application.905597d0.js"></script>
      
        
        
          
          <script src="../../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
                <script src="../../../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../../../assets/javascripts/lunr/lunr.jp.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../../.."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
    
      
    
  </body>
</html>